using System;
using System.Collections;
using System.Text.Json;
using ProceduralBiomesTool.Rules;

namespace ProceduralBiomesTool.Resources;

/// <summary>
/// Defines a group of assets and how they should be generated by the biome tool.
/// </summary>
[GameResource("Ecotope", "ecotope", "Defines how a biome looks.", Icon = "forest", Category = "World")]
public class EcotopeResource : GameResource
{
	[Property, Description("What color will this show up as when painting biomes onto terrain?")]
	public Color VisualizationColor { get; set; } = Color.Red;

	[Property, Description("Global modifier for how densely packed objects generated by this ecotope are.")]
	[Range(0, 1)] public float Density { get; set; } = 1f;
	
	[Property] public EcotopeLayer[] Layers { get; set; } = [];
	[Property] public EcotopeGlobalRules Rules { get; set; } = new();
	[Property] public bool HandledPostCreationSetup { get; set; }
	
	/// <summary>
	/// Create a new layer in this ecotope.
	/// </summary>
	public void AddNew()
	{
		var layer = new EcotopeLayer()
		{
			LayerName = "New Layer"
		};
		layer.ResetToDefaultRules();
		
		var t = Layers.ToList();
		t.Add(layer);
		Layers = t.ToArray();
	}
	
	/// <summary>
	/// Move a layer further up or down in the layers list.
	/// </summary>
	public void Swap(int index, int delta)
	{
		int newIndex = index + delta;
		if (newIndex < 0 || newIndex >= Layers.Length)
			return;
		
		(Layers[index], Layers[newIndex]) = (Layers[newIndex], Layers[index]);
	}

	public void MoveToTop(int index)
	{
		int moveIndex = index;
		for (int i = 0; i < index; ++i)
		{
			Swap(moveIndex, -1);
			moveIndex--;
		}
	}
	
	public void MoveToBottom(int index)
	{
		for (int i = index; i < Layers.Length; ++i)
		{
			Swap(index, 1);
			index++;
		}
	}
	
	/// <summary>
	/// Remove a particular layer at the specified index.
	/// </summary>
	public void RemoveAt(int index)
	{
		var t = Layers.ToList();
		t.RemoveAt(index);
		Layers = t.ToArray();
	}
	
	public void ResetToDefaultRules()
	{
		Rules = new EcotopeGlobalRules();
		Rules.Add(new RemoveOverlappingFootprintsGlobalRule());
		Rules.Add(new RemoveCollidingObjectsGlobalRule());
		Rules.Add(new ApplyTagsGlobalRule()
		{
			Tags = ["generated"]
		});
	}
}

/// <summary>
/// An individual collection of assets in an ecotope and the rules used to define how they are generated.
/// </summary>
public class EcotopeLayer
{
	[Property] public string LayerName { get; set; }
	[Property, InlineEditor] public EcotopeLayerAssetReference[] Assets { get; set; } = [];
	[Property] public EcotopeLayerRules Rules { get; set; } = new();
	
	public void ResetToDefaultRules()
	{
		Rules = new EcotopeLayerRules();
		Rules.Add(new GeneratePoissonDiscDistributionLayerRule());
		Rules.Add(new RemovePointsOnInvalidTerrainLayerRule());
		Rules.Add(new AlignToTerrainLayerRule());
		Rules.Add(new ApplyRandomYawLayerRule());
		Rules.Add(new RemovePointsTouchingCollisionLayerRule());
	}
}

/// <summary>
/// A reference to an ecotope asset for use in a layer, allows setting some 
/// </summary>
public class EcotopeLayerAssetReference
{
	[Property] public EcotopeAssetResource Asset { get; set; }
	[Property, Range(0, 1)] public float Density { get; set; } = 1f;
}

/// <summary>
/// A generic serializable collection of rules used by an Ecotope Resource.
/// </summary>
public class EcotopeGlobalRules : IJsonConvert, IEnumerable<EcotopeGlobalRule>
{
	private List<EcotopeGlobalRule> internalRules = new();
	
	[Property]
	private List<EcotopeGlobalRule> Rules
	{
		get
		{
			internalRules ??= new List<EcotopeGlobalRule>();
			return internalRules;
		}
		set => internalRules = value;
	}

	public int Count => Rules.Count;
	
	public EcotopeGlobalRule this[int i]
	{
		get => Rules[i];
		set => Rules[i] = value;
	}
	
	public EcotopeGlobalRule AddNew(TypeDescription type)
	{
		var instance = type.Create<EcotopeGlobalRule>();
		Rules.Add(instance);
		return instance;
	}

	public void Add(EcotopeGlobalRule rule)
	{
		Rules.Add(rule);
	}

	public void Swap(int index, int delta)
	{
		int newIndex = index + delta;
		if (newIndex < 0 || newIndex >= Count)
			return;
		
		(Rules[index], Rules[newIndex]) = (Rules[newIndex], Rules[index]);
	}

	public void MoveToTop(int index)
	{
		int moveIndex = index;
		for (int i = 0; i < index; ++i)
		{
			Swap(moveIndex, -1);
			moveIndex--;
		}
	}
	
	public void MoveToBottom(int index)
	{
		for (int i = index; i < Count; ++i)
		{
			Swap(index, 1);
			index++;
		}
	}
	
	public void RemoveAt(int index)
	{
		internalRules.RemoveAt(index);
	}
	
	public IEnumerator<EcotopeGlobalRule> GetEnumerator()
	{
		foreach (var rule in internalRules)
		{
			if(rule == null) continue;
			yield return rule;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
	
	public static void JsonWrite(object value, Utf8JsonWriter writer)
	{
		if (!(value is EcotopeGlobalRules globalRules))
			throw new NotImplementedException();
		
		int count = globalRules.Count;
		writer.WriteStartObject();
		writer.WriteNumber("count", count);
		writer.WriteStartArray("rules");
		
		foreach(var rule in globalRules.Rules)
		{
			writer.WriteStartObject();
			writer.WriteString("type", rule.GetType().Name);
			writer.WriteString("data", Sandbox.Json.Serialize(rule));
			writer.WriteEndObject();
		}
		writer.WriteEndArray();
		writer.WriteEndObject();
	}
	
	public static object JsonRead(ref Utf8JsonReader reader, Type typeToConvert)
	{
		var jsonObject = Sandbox.Json.ParseToJsonObject(ref reader);
		if (jsonObject == null)
			return null;

		if (!jsonObject.TryGetPropertyValue("count", out var countNode))
			return null;
		
		int count = countNode!.GetValue<int>();
		var globalRules = new EcotopeGlobalRules();
		
		if (jsonObject.TryGetPropertyValue("rules", out var rulesArrayNode))
		{
			var array = rulesArrayNode!.AsArray();
			for (int i = 0; i < count; ++i)
			{
				var ruleNode = array[i]!.AsObject();

				if (ruleNode.TryGetPropertyValue("type", out var t) && ruleNode.TryGetPropertyValue("data", out var d))
				{
					var type = TypeLibrary.GetType(t!.GetValue<string>())?.TargetType;
					if (type == null)
						continue; // type is null, we probably renamed or removed it, so ignore it
					
					if (Sandbox.Json.Deserialize(d!.GetValue<string>(), type) is EcotopeGlobalRule instance)
					{
						globalRules.Rules.Add(instance);
					}
				}
			}
		}
		
		return globalRules;
	}
}

/// <summary>
/// A generic serializable collection of rules used by an Ecotope Layer.
/// </summary>
public class EcotopeLayerRules : IJsonConvert, IEnumerable<EcotopeLayerRule>
{
	private List<EcotopeLayerRule> internalRules = new();
	
	[Property]
	private List<EcotopeLayerRule> Rules
	{
		get
		{
			internalRules ??= new List<EcotopeLayerRule>();
			return internalRules;
		}
		set => internalRules = value;
	}

	public int Count => Rules.Count;
	
	public EcotopeLayerRule this[int i]
	{
		get => Rules[i];
		set => Rules[i] = value;
	}
	
	public EcotopeLayerRule AddNew(TypeDescription type)
	{
		var instance = type.Create<EcotopeLayerRule>();
		Rules.Add(instance);
		return instance;
	}

	public void Add(EcotopeLayerRule rule)
	{
		Rules.Add(rule);
	}

	public void Swap(int index, int delta)
	{
		int newIndex = index + delta;
		if (newIndex < 0 || newIndex >= Count)
			return;
		
		(Rules[index], Rules[newIndex]) = (Rules[newIndex], Rules[index]);
	}

	public void MoveToTop(int index)
	{
		int moveIndex = index;
		for (int i = 0; i < index; ++i)
		{
			Swap(moveIndex, -1);
			moveIndex--;
		}
	}
	
	public void MoveToBottom(int index)
	{
		for (int i = index; i < Count; ++i)
		{
			Swap(index, 1);
			index++;
		}
	}

	public void RemoveAt(int index)
	{
		internalRules.RemoveAt(index);
	}
	
	public IEnumerator<EcotopeLayerRule> GetEnumerator()
	{
		foreach (var rule in internalRules)
		{
			if(rule == null) continue;
			yield return rule;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
	
	public static void JsonWrite(object value, Utf8JsonWriter writer)
	{
		if (value is not EcotopeLayerRules layerRules)
			throw new NotImplementedException();
		
		int count = layerRules.Rules.Count;
		writer.WriteStartObject();
		writer.WriteNumber("count", count);
		writer.WriteStartArray("rules");
		foreach(var rule in layerRules.Rules)
		{
			writer.WriteStartObject();
			writer.WriteString("type", rule.GetType().Name);
			writer.WriteString("data", Sandbox.Json.Serialize(rule));
			writer.WriteEndObject();
		}
		writer.WriteEndArray();
		writer.WriteEndObject();
	}
	
	public static object JsonRead(ref Utf8JsonReader reader, Type typeToConvert)
	{
		var jsonObject = Sandbox.Json.ParseToJsonObject(ref reader);
		if (jsonObject == null)
			return null;

		if (!jsonObject.TryGetPropertyValue("count", out var countNode))
			return null;
		
		int count = countNode!.GetValue<int>();
		var layerRules = new EcotopeLayerRules();
		
		if (jsonObject.TryGetPropertyValue("rules", out var rulesArrayNode))
		{
			var array = rulesArrayNode!.AsArray();
			for (int i = 0; i < count; ++i)
			{
				var ruleNode = array[i]!.AsObject();

				if (ruleNode.TryGetPropertyValue("type", out var t) && ruleNode.TryGetPropertyValue("data", out var d))
				{
					var type = TypeLibrary.GetType(t!.GetValue<string>())?.TargetType;
					if (type == null)
						continue; // type is null, we probably renamed or removed it, so ignore it
					
					if (Sandbox.Json.Deserialize(d!.GetValue<string>(), type) is EcotopeLayerRule instance)
					{
						layerRules.Rules.Add(instance);
					}
				}
			}
		}
		
		return layerRules;
	}
}
